#!/usr/bin/bash
# Copyright (C) 2015-2016 Eric Vidal <eric@obarun.org>
#
# This file is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.
#
# This scripts is under License Beerware.
#
# "THE BEERWARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal http://obarun.org

##		define some variables

LIST_SERV=()
S6OPTS_CONF="/etc/obarun/s6opts.conf"

## 		common functions

usage(){
	cat << EOF
	
${bold}Usage: ${0} [options] [service_name|database_name]${reset}

General options:
	add : add a service on service database
	all : compile and switch the current database
	compile : compile the service database
	disable : disable a classic service from boot time
	enable : enable a classic service at boot time
	list : list service enabled on database for compilation
	list_db : list of services on current database
	remove : remove a service on service database
	remove_db : remove a service database
	switch : switch the current service database and bring up all new service
	verbose : be more or less verbose (permanent change)
	which_db : current/previous service database used
EOF
	exit 0
}

##		main fonction

# ${1} name of the service to add
# ${2} name of the source where add the service
add(){
	local named where
	where="${1}"
	named="${2}"
	
	#check if exist or not
	check_dir "${AVAILABLE_PATH}/${named}"
	if (( $? )); then # rc=1
		echo_error " ${named} doesn't exist, choose an another name"
		exit 1
	fi	
		
	# check if directory where exist
	# if not, create it with the necessary file/folder
	check_dir "${ENABLED_PATH}/${where}"
	if (( $? )); then
		echo_display " ${where} does not exist, create it with the necessary files"
		mkdir -p -m 0755 "${ENABLED_PATH}/${where}" || die "Impossible to create the directroy ${ENABLED_PATH}/${where}"
		cp -r "${ENABLED_PATH}/default/All" "${ENABLED_PATH}/${where}" || die "Impossible to copy from ${ENABLED_PATH}/All to ${ENABLED_PATH}/${where}"
	else
		if ! [[ -d "${ENABLED_PATH}/${where}/All" ]]; then
			echo_info " Folder All does not exist, create it" 
			cp -r "${ENABLED_PATH}/default/All" "${ENABLED_PATH}/${where}" || die "Impossible to copy from ${ENABLED_PATH}/All to ${ENABLED_PATH}/${where}"
		fi
	fi
	
	
	# bundle or classic service?
	search_in_dir "${AVAILABLE_PATH}" "${named}" "contents"
	
	# if bundle, create symlink for all name in contents file 
	if (( ! $? )); then # it is a bundle
		parse_file "${AVAILABLE_PATH}/${named}" "contents"
		while read -d "," line; do
			cp -rau "${AVAILABLE_PATH}/${line}" "${ENABLED_PATH}/${where}"
		done <<< "${LIST_SERV[@]}"
		LIST_SERV=()
		cp -rau "${AVAILABLE_PATH}/${named}" "${ENABLED_PATH}/${where}" 
				
		# be sure that the name doesn't exist on file contents
		search_in_file "${ENABLED_PATH}/${where}/All" "contents" "${named}"
		if (( $? )); then
			echo "${named}" >> "${ENABLED_PATH}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${ENABLED_PATH}/${where}/All/contents"
		fi
	else
		cp -rau "${AVAILABLE_PATH}/${named}" "${ENABLED_PATH}/${where}"
		
		# be sure that the name doesn't exist on file contents
		search_in_file "${ENABLED_PATH}/${where}/All" "contents" "${named}"
		if (( $? )); then
			echo "${named}" >> "${ENABLED_PATH}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${ENABLED_PATH}/${where}/All/contents"
		fi
	fi
	
	unset named where
	
	exit 0
}

# ${1} name of the service to remove
# ${2} name of the source where remove the service
remove(){
	local named
	where="${1}"
	named="${2}"
	
	#check if exist or not
	check_dir "${ENABLED_PATH}/${where}" "${named}"
	if (( $? )); then # rc=1
		echo_error " ${named} doesn't exist, choose an another name"
		exit 1
	fi
	
	# bundle or classic service?
	search_in_dir "${AVAILABLE_PATH}" "${named}" "contents"
	
	# if bundle, remove symlink for all name in contents file 
	if (( ! $? )); then # it is a bundle
		parse_file "${ENABLED_PATH}/${where}/${named}" "contents"
		while read -d "," line; do
			rm -r "${ENABLED_PATH}/${where}/${line}"
			search_in_file "${ENABLED_PATH}/${where}/All" "contents" "${line}"
			if (( ! $? )); then
				sed -i "s:${line}::" "${ENABLED_PATH}/${where}/All/contents"
				# remove empty line
				sed -i "/^\s*$/d" "${ENABLED_PATH}/${where}/All/contents"
			fi
		done <<< "${LIST_SERV[@]}"
		LIST_SERV=()
		rm -r "${ENABLED_PATH}/${where}/${named}" 
		
		# remove bundle name on file contents
		search_in_file "${ENABLED_PATH}/${where}/All" "contents" "${named}"
		if (( ! $? )); then
			sed -i "s:${named}::" "${ENABLED_PATH}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${ENABLED_PATH}/${where}/All/contents"
		fi
	else
		rm -r "${ENABLED_PATH}/${where}/${named}"
		# remove service name on file contents
		search_in_file "${ENABLED_PATH}/${where}/All" "contents" "${named}"
		if (( ! $? )); then
			sed -i "s:${named}::" "${ENABLED_PATH}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${ENABLED_PATH}/${where}/All/contents"
		fi
	fi
	
	unset named
	
	exit 0
}

# ${1} name of the future compiled database
# ${2} name of the source to compile the database
compile(){
	local named rc_curr curr curr_parse
	#named="${1:-current}"
	named="${1}"
	with_="${2}"
	rc_curr=1
	curr=$(which_db current)
	curr_parse=${curr##*/}
	
	check_dir "${DATABASE_PATH}/${named}.old"
	if (( ! $? )); then
		rc_curr=0
	fi
		
	if [[ "${named}" == "current" ]] || [[ "${named}" == "${curr_parse}" ]]; then
		named=${curr}
		named=${named##*/}
		if (( "$rc_curr" )); then # .old do not exist
		    cp -rf "${DATABASE_PATH}/${named}" "${DATABASE_PATH}/${named}.old" || die "Impossible to cp ${named} to ${named}.old"
		    s6-rc-update -l "${LIVE_PATH}" -v"${VERBOSE}" "${DATABASE_PATH}/${named}.old" || die "Impossible to update the new database"
		    rm -r "${DATABASE_PATH}/${named}" || die "Impossible to remove ${named}"
		    make_symlinks "-sfT" "${DATABASE_PATH}/${named}.old" "${DATABASE_PATH}" "current" || die "Impossible to create current symlinks"
		else # .old exist
		    s6-rc-update -l "${LIVE_PATH}" -v"${VERBOSE}" "${DATABASE_PATH}/${named}.old" || die "Impossible to update the new database"
		    rm -r "${DATABASE_PATH}/${named}" || die "Impossible to remove ${named}"
		    make_symlinks "-sfT" "${DATABASE_PATH}/${named}.old" "${DATABASE_PATH}" "current" || die "Impossible to create current symlinks"
		fi
	fi

	# check exist or not
	check_dir "${DATABASE_PATH}/${named}"
	if (( ! $? )); then
		rm -r "${DATABASE_PATH}/${named}" || die "Impossible to remove ${named}"
	fi
	
	# compile new database
	s6-rc-compile -v"${VERBOSE}" "${DATABASE_PATH}/${named}" "${ENABLED_PATH}/${with_}" || die "Impossible to compile the new database"
	
	unset named rc_curr curr curr_parse
}

# ${1} name of the database to switch
switch(){
	local named rc_curr rc_first curr curr_parse prev prev_parse
	local -a which_up prev_db
	#named="${1:-current}"
	named="${1}"
	rc_curr=1
	rc_first=1
	curr=$(which_db current)
	curr_parse=${curr##*/}
	prev=$(which_db previous)
	prev_parse=${prev##*/}
	
	# need to know if it's the first use of s6opts
	if [[ "${curr_parse}" == "default" ]] && [[ "${prev_parse}" == "default" ]]; then
		rc_first=0
	fi
	
	# check if exist or not
	check_dir "${DATABASE_PATH}/${named}"
	if (( $? )); then
		die "$named doesn't exist, please choose another one"
	fi
		
	# change place of previous symlinks
	make_symlinks "-sfT" "${curr}" "${DATABASE_PATH}" "previous" || die "Impossible to create previous symlinks"
	
	# udpate current database to new database
	s6-rc-update -l "${LIVE_PATH}" -v"${VERBOSE}" "${DATABASE_PATH}/${named}" || die "Impossible to update the new database"
	
	# search in old db for know what services is new 
	# then bring up only the new services
	
	if (( ! rc_first)); then # first pass?
	    s6-rc -l "${LIVE_PATH}" -v"${VERBOSE}" -u change all-User
	else
	    curr_parse="${named}"
	    prev=$(which_db previous)
	    prev_parse="${prev##*/}"

	    compare_db "${curr_parse}" "${prev_parse}"
	fi
	
	# update the symlinks to boot with the new database
	make_symlinks "-sfT" "${DATABASE_PATH}/${named}" "${DATABASE_PATH}" "current" || die "Impossible to create current symlinks"
	
	unset named rc_curr rc_first curr curr_parse prev prev_parse 
}

# ${1} name of the future compiled database
# ${2} name of the source to compile the database
compile_switch(){
	local named
	#named="${1:-current}"
	named="${1}"
	who_="${2}"
	
	compile  "${named}" "${who_}" 
	switch "${named}"
	
	unset named
	
	exit 0
}

# ${1} name of symlinks, blank for both
which_db(){
	local named
	named="${1}"
	
	if [[ -z "${named}" ]]; then
		stat -c%N "${DATABASE_PATH}/current"
		stat -c%N "${DATABASE_PATH}/previous"
	else	
		readlink -v "${DATABASE_PATH}/${named}"
	fi
	
	unset named
}

# ${1} which database, blank for live
list_db(){
	local named
	named="${1}"
	
	if [[ -z "${named}" ]]; then
	    s6-rc-db -l "${LIVE_PATH}" list all
	else
	    s6-rc-db -c "${DATABASE_PATH}/${named}" list all
	fi
	
	unset named
	
	exit 0
}

# ${1} working database directory
list(){
	local named
	named="${1}"
	
	ls -1 --color --group-directories-first "${ENABLED_PATH}/${named}"
		
	unset named
}

verbose(){
	local verb
	verb="${1}"
	
	if [[ "${verb}" != @(0|1|2|3) ]]; then
		die "the number must be 0,1,2 or 3"
	fi
	
	sed -i "s:VERBOSE=.*$:VERBOSE=${verb}:" "${S6OPTS_CONF}"
	
	unset verb 
	
	exit 0
}

remove_db(){
	local named curr
	named="${1}"
	curr=$(which_db current)
	
	if [[ "${DATABASE_PATH}/${named}" == "${curr}" ]]; then
		die "Removing the current database is not allowed"
	fi
	
	rm -r "${DATABASE_PATH}/${named}"
	
	unset named curr
	
	exit 0
}

# ${1} name of the service
enable(){
	local named
	named="${1}"
	
	check_dir "${CLASSIC_AVAILABLE}/${named}"
	if (( ! $? )); then
		if [[ -d "${CLASSIC_PATH}/${named}" ]]; then
			echo_info "${named} already exist at ${CLASSIC_PATH}, do you want to synchronize it [y|n]"
			reply_answer
			if (( ! $? )); then
				cp -ra "${CLASSIC_AVAILABLE}/${named}" "${CLASSIC_PATH}/" || die "Impossible to copy ${named} to ${CLASSIC_PATH}"
			else
				echo_valid " Keeping the old version"
			fi
		else
			cp -r "${CLASSIC_AVAILABLE}/${named}" "${CLASSIC_PATH}/${named}" || die "Impossible to copy ${named} to ${CLASSIC_PATH}"
		fi
	else
		die "${named} does not exist, choose another one"
	fi
		
	if [[ -h "${CLASSIC_ENABLED}/${named}" ]]; then
		echo_info " Already enabled, do you want to send a ALARM signal to ${named} [y|n]"
		reply_answer
		if (( ! $? )); then
			s6-svc -a "${CLASSIC_ENABLED}/""${named}"
		fi
	else
		echo_display " Enable ${named}"
		make_symlinks "-s" "${CLASSIC_PATH}/${named}" "${CLASSIC_ENABLED}" "${named}"
		
		echo_display " Bringing up ${named}"
		s6-svscanctl -an "${CLASSIC_ENABLED}"
	fi
	
	exit 0
}

# ${1} name of the service
disable(){
	local named
	named="${1}"
	link_=$(readlink "${CLASSIC_ENABLED}/${named}")
	
	if [[ "${link_}" != "${CLASSIC_PATH}/${named}" ]]; then
		die " Not a classic service, choose another one"
	fi
	if [[ ! -h "${CLASSIC_ENABLED}/${named}" ]]; then
		echo_info " Not enabled, nothing to do"
		exit 0
	fi

	echo_display " Bringing down ${named}"
	s6-svc -d "${CLASSIC_ENABLED}/""${named}"
	
	check_dir "${CLASSIC_PATH}/${named}"
	if (( ! $? )); then
		rm -rf "${CLASSIC_PATH}/${named}" || die " Impossible to remove ${named}"
	fi
	
	
	
	echo_display " Disable ${named}"
	rm "${CLASSIC_ENABLED}/${named}"
	
	echo_display " Synchronize ${CLASSIC_ENABLED} directory"
	s6-svscanctl -an "${CLASSIC_ENABLED}"
	
	exit 0
	
}
##		sub functions

# ${1} path to the database
# ${2} name of the database
# ${3} searched on to the database
# return 0 on success, 1 on fail
search_in_db(){
	local path_file named search line_ in_db
	path_file="${1:-${DATABASE_PATH}}"
	named="${2:-current}"
	search="${3}"
	in_db="${path_file}/${named}"
	
	while read line_; do
		case $line_ in
			$search) return 0 && break ;;
			*) return 1 ;;
		esac
	done < <(s6-rc-db -c "${in_db}" list all)
	
	unset path_file named search line_ in_db
}

# ${1} path to the file
# ${2} file to parse
parse_file(){
	local check path_file named
	path_file="${1}"
	named="${2}"
	
	while read check; do
		LIST_SERV+=($check,)
	done < "${path_file}/${named}"

	unset check path_file named
}

# ${1} action, must be u for up or d for down
# ${2} name of the bundle/service to bring up/down
bringing(){
	local action named
	action="${1}"
	named="${2}"
	
	echo_display " Bringing ${action} ${named}"
	s6-rc -l "${LIVE_PATH}" -v${VERBOSE} -"${action}" change "${named}"
	
	unset action named
}

# ${1} current database
# ${2} previous database
compare_db(){
	local curr prev check line_
	local -a curr_db which_up
	curr="${1}"
	prev="${2}"

	mapfile -t curr_db < <(s6-rc-db -c "${DATABASE_PATH}/${curr}" list all)

	while read -d " " check; do
		search_in_db "" "${prev}" "${check}"
		if (( $? )); then
			which_up+=($check,)
		fi
	done <<< "${curr_db[@]}"
	
	# bring up the new service
	while read -d "," line_; do
		bringing "u" "$line_"
	done <<<  "${which_up[@]}"
	
	unset curr prev check line_ curr_db which_up
}

