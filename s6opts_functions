#!/bin/bash

#set -e

. /etc/s6opts/s6opts.conf

##		Shell color 

bold=$(tput bold)
reset=$(tput sgr0)
red=$(tput setaf 1)
bred=${bold}$(tput setaf 1)
green=$(tput setaf 2)
bgreen=${bold}$(tput setaf 2)
yellow=$(tput setaf 3)
byellow=${bold}$(tput setaf 3)
blue=$(tput setaf 4)
bblue=${bold}$(tput setaf 4)


## 		Information display by the script 

echo_bold(){
	local msg=$1; shift 
	printf "${bold}${msg}${reset}\n" "${@}" >&1
}
echo_info(){
	local msg=$1; shift 
	printf "${byellow}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_info_menu(){
	local msg=$1; shift 
	printf "${byellow}${msg} ${reset}\n" "${@}" >&1
}
echo_retry(){
	local msg=$1; shift 
	printf "${bblue}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_valid(){
	local msg=$1; shift 
	printf "${bgreen}    ->${msg} ${reset}\n" "${@}" >&1
}
echo_notvalid(){
	local msg=$1; shift 
	printf "${byellow}    ->${msg} ${reset}\n" "${@}" >&1
}
echo_display(){
	local msg=$1; shift 
	printf "${bold}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_error(){
	local msg=$1; shift 
	printf "${bred}    ->${msg} ${reset}\n" "${@}" >&2
}
answer(){
	echo_retry " Please answer y or n :"
}

##		define some variables
reply=""
list_serv=()
rc=""

## 		common functions

die (){
      local message 
      message="$1"
 
      if [[ -n "$message" ]] ; then
        echo "${bred}==>> Error: ${message}${reset}"
      else
        echo "${bred}==>> Error: Script can not continue"
      fi
      exit 1
}

check_elements(){
	for e in "${@:2}"; do [[ "${e}" == "${1}" ]] && break; done;
}

usage(){
	echo ""
	echo_bold " Usage: ${0} [options] [service_name|database_name]"
	echo ""
	echo " General options:"
    echo "     add : add a service on service database"
    echo "     remove : remove a service on service database"
    echo "     compile : compile the service database"
    echo "     switch : switch the current service database"
    echo "     all : compile and switch the current database"
	echo "     list : list of services on current database"
	echo "     verbose : be more or less verbose (permanent change)"
	echo "     remove_db : remove a service database"
	echo "     which_db : current/previous service database used"
}

##		main fonction

add(){
	local named
	named="${1}"
	
	#check if exist or not
	check_dir "${available_path}/${named}"
	if (( "$rc" )); then # rc=1
		echo_error " ${named} doesn't exist, choose an another name"
		unset rc
		exit 1
	fi	
	unset rc
	
	# bundle or classic service?
	search_in_dir "${available_path}" "${named}" "contents"
	
	# if bundle, create symlink for all name in contents file 
	if (( ! "$rc" )); then # it is a bundle
		unset rc
		parse_file "${available_path}/${named}" "contents"
		while read -d "," line; do
			make_symlinks "-sfT" "${available_path}/${line}" "${enabled_path}" "${line}"
		done <<< "${list_serv[@]}"
		list_serv=()
		unset rc
		make_symlinks "-sfT" "${available_path}/${named}" "${enabled_path}" "${named}"
		
		# be sure that the name doesn't exist on file contents
		search_in_file "${available_path}/all-User" "contents" "${named}"
		if (( "$rc" )); then
			unset rc
			echo "${named}" >> "${available_path}/all-User/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${available_path}/all-User/contents"
		fi
		unset rc
	else
		unset rc
		make_symlinks "-sfT" "${available_path}/${named}" "${enabled_path}" "${named}"
		
		# be sure that the name doesn't exist on file contents
		search_in_file "${available_path}/all-User" "contents" "${named}"
		if (( "$rc" )); then
			unset rc
			echo "${named}" >> "${available_path}/all-User/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${available_path}/all-User/contents"
		fi
		unset rc
	fi
	unset named
	exit 0
}

remove(){
	local named
	named="${1}"
	
	#check if exist or not
	check_dir "${enabled_path}/${named}"
	if (( "$rc" )); then # rc=1
		unset rc
		echo_error " ${named} doesn't exist, choose an another name"
		exit 1
	fi
	unset rc
	
	# bundle or classic service?
	search_in_dir "${available_path}" "${named}" "contents"
	
	# if bundle, remove symlink for all name in contents file 
	if (( ! "$rc" )); then # it is a bundle
		unset rc
		parse_file "${enabled_path}/${named}" "contents"
		while read -d "," line; do
			rm "${enabled_path}/${line}"
			search_in_file "${available_path}/all-User" "contents" "${line}"
			if (( ! "$rc" )); then
				unset rc
				sed -i "s:${line}::" "${available_path}/all-User/contents"
				# remove empty line
				sed -i "/^\s*$/d" "${available_path}/all-User/contents"
			fi
		done <<< "${list_serv[@]}"
		list_serv=()
		unset rc
		rm "${enabled_path}/${named}" 
		
		# remove bundle name on file contents
		search_in_file "${available_path}/all-User" "contents" "${named}"
		if (( ! "$rc" )); then
			unset rc
			sed -i "s:${named}::" "${available_path}/all-User/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${available_path}/all-User/contents"
		fi
		unset rc
	else
		unset rc
		rm "${enabled_path}/${named}"
		# remove service name file contents
		search_in_file "${available_path}/all-User" "contents" "${named}"
		if (( ! "$rc" )); then
			unset rc
			sed -i "s:${named}::" "${available_path}/all-User/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${available_path}/all-User/contents"
		fi
		unset rc
	fi
	
	unset named
	
	exit 0
}

compile(){
	local named
	named="${1}"
	
	# check exist or not
	check_dir "${database_path}/${named}"
	if (( ! "$rc" )); then
		die "${named} database already exist, please choose another one"
	fi
	unset rc
	
	# compile new database
	s6-rc-compile -v"${verbose}" "${database_path}/${named}" "/etc/s6/rc-serv-boot" "${enabled_path}" || die "Impossible to compile the new database"
	
	unset named
}

switch(){
	local named curr
	named="${1}"
	curr=$(which_db current)
	
	# check if exist or not
	check_dir "${database_path}/${named}"
	if (( "$rc" )); then
		die "$named doesn't exist, please choose another one"
	fi
	unset rc
	
	# udpate current database to new database
	s6-rc-update -v"${verbose}" "${database_path}/${named}" || die "Impossible to update the new database"
	
	# update the symlinks about previous database
	make_symlinks "-sfT" "${curr}" "${database_path}" "previous" || die "Impossible to create previous symlinks"
	# update the symlinks to boot with the new database
	make_symlinks "-sfT" "${database_path}/${named}" "${database_path}" "current" || die "Impossible to create current symlinks"
	
	unset named	curr
}

compile_switch(){
	local named
	named="${1}"
	
	compile "${named}"
	switch "${named}"
	
	unset named curr
	
	exit 0
}

# ${1} name of symlinks
which_db(){
	local named
	named="${1}"
	
	if [[ -z "${named}" ]]; then
		stat -c%N "${database_path}/current"
		stat -c%N "${database_path}/previous"
	else	
		readlink -v "${database_path}/${1}"
	fi
	
	unset named
	
	exit 0
}


list(){
	s6-rc -a listall
	exit 0
}

verbose(){
	local verb
	verb="${1}"
	
	if [[ "${verb}" != @(0|1|2|3) ]]; then
		die "the number must be 0,1,2 or 3"
	fi
	
	sed -i "s:verbose=.*$:verbose=${verb}:" /etc/s6opts/s6opts.conf
	
	unset verb 
	
	exit 0
}

remove_db(){
	local named curr
	named="${1}"
	curr=$(which_db current)
	
	if [[ "${database_path}/${named}" == "${curr}" ]]; then
		die "Removing the current database is not allowed"
	fi
	
	rm -r "${database_path}/${named}"
	
	unset named curr
	
	exit 0
}
	
##		sub functions

# ${1} path directories
# ${2} name of directory
# ${3} searched files
# return rc=0 success, rc=1 fail
search_in_dir(){
	local path_dir search named sub_dir 
	local -a list files
	path_dir="${1}"
	named="${2}"
	search="${3}"
	
	mapfile -t list < <(ls --group-directories-first -m ${path_dir}/)
	
	for sub_dir in "${named}"; do
		mapfile -t files < <(ls --group-directories-first -m ${path_dir}/${named})
		while read -d "," here; do
			case $here in
				$search) rc=0 && break ;;
				*) rc=1 ;;
			esac
		done <<< ${files[@]}
	done <<< "${list[@]}"
	
	unset path_dir search named sub_dir list files
}


# ${1} path to the file
# ${2} name of the file
# ${3} searched on to the file
# return rc=0 on success, rc=1 on fail
search_in_file(){
	local path_file named search line
	path_file="${1}"
	named="${2}"
	search="${3}"
	in_file="${path_file}/${named}"
	while read line;do
		case $line in
			$search) rc=0 && break ;;
			*) rc=1 ;;
		esac
	done < "${in_file}"
	
	unset path_file named search line in_file
}

# ${1} path to the file
# ${2} file to parse
parse_file(){
	local check path_file named
	path_file="${1}"
	named="${2}"
	while read check; do
		list_serv+=($check,)
	done < "${path_file}/${named}"

	unset check path_file named
}

# ${1} option to pass
# ${2} target 
# ${3} where to create it
# ${4} name of the symlinks
make_symlinks(){
	local opt target where named
	opt="${1}"
	target="${2}"
	where="${3}"
	named="${4}"

	ln "${opt}" "${target}" "${where}/${named}"

	unset opt target where named
}

# ${1} name of the directory
# return rc=0 on success
check_dir(){
	local dir
	dir="${1}"
	if [ -d "${dir}" ]; then
		rc=0
	else
		rc=1
	fi
	
	unset dir
}


