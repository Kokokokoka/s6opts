#!/bin/bash
# Copyright (C) 2015-2016 Eric Vidal <eric@obarun.org>
#
# This file is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.
#
# This scripts is under License Beerware.
#
# "THE BEERWARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal http://obarun.org

#set -e

source /usr/lib/obarun/common_functions
source /etc/obarun/s6opts.conf

##		define some variables

list_serv=()
rc=""

## 		common functions

usage(){
	cat << EOF
	
${bold}Usage: ${0} [options] [service_name|database_name]${reset}

General options:
	add : add a service on service database
	all : compile and switch the current database
	compile : compile the service database
	disable : disable a classic service from boot time
	enable : enable a classic service at boot time
	list : list service enabled on database for compilation
	list_db : list of services on current database
	remove : remove a service on service database
	remove_db : remove a service database
	switch : switch the current service database and bring up all new service
	verbose : be more or less verbose (permanent change)
	which_db : current/previous service database used
EOF
	exit 0
}

##		main fonction

# ${1} name of the service to add
# ${2} name of the source where add the service
add(){
	local named where
	where="${1}"
	named="${2}"
	
	#check if exist or not
	check_dir "${available_path}/${named}"
	if (( "$rc" )); then # rc=1
		echo_error " ${named} doesn't exist, choose an another name"
		unset rc
		exit 1
	fi	
	unset rc
	
	# check if directory where exist
	# if not, create it with the necessary file/folder
	check_dir "${enabled_path}/${where}"
	if (( "$rc" )); then
		unset rc
		echo_display " ${where} does not exist, create it with the necessary files"
		mkdir -p -m 0755 "${enabled_path}/${where}" || die "Impossible to create the directroy ${enabled_path}/${where}"
		cp -r "${enabled_path}/default/All" "${enabled_path}/${where}" || die "Impossible to copy from ${available_path}/all-User to ${enabled_path}/${where}"
	else
	unset rc
		if ! [[ -d "${enabled_path}/${where}/All" ]]; then
			echo_info " Folder All does not exist, create it" 
			cp -r "${enabled_path}/default/All" "${enabled_path}/${where}" || die "Impossible to copy from ${available_path}/all-User to ${enabled_path}/${where}"
		fi
	fi
	
	unset rc
	
	# bundle or classic service?
	search_in_dir "${available_path}" "${named}" "contents"
	
	# if bundle, create symlink for all name in contents file 
	if (( ! "$rc" )); then # it is a bundle
		unset rc
		parse_file "${available_path}/${named}" "contents"
		while read -d "," line; do
			cp -rau "${available_path}/${line}" "${enabled_path}/${where}"
		done <<< "${list_serv[@]}"
		list_serv=()
		unset rc
		cp -rau "${available_path}/${named}" "${enabled_path}/${where}" 
				
		# be sure that the name doesn't exist on file contents
		search_in_file "${enabled_path}/${where}/All" "contents" "${named}"
		if (( "$rc" )); then
			unset rc
			echo "${named}" >> "${enabled_path}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
		fi
		unset rc
	else
		unset rc
		cp -rau "${available_path}/${named}" "${enabled_path}/${where}"
		
		# be sure that the name doesn't exist on file contents
		search_in_file "${enabled_path}/${where}/All" "contents" "${named}"
		if (( "$rc" )); then
			unset rc
			echo "${named}" >> "${enabled_path}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
		fi
		unset rc
	fi
	
	unset named where
	
	exit 0
}

# ${1} name of the service to remove
# ${2} name of the source where remove the service
remove(){
	local named
	where="${1}"
	named="${2}"
	
	#check if exist or not
	check_dir "${enabled_path}/${where}" "${named}"
	if (( "$rc" )); then # rc=1
		unset rc
		echo_error " ${named} doesn't exist, choose an another name"
		exit 1
	fi
	unset rc
	
	# bundle or classic service?
	search_in_dir "${available_path}" "${named}" "contents"
	
	# if bundle, remove symlink for all name in contents file 
	if (( ! "$rc" )); then # it is a bundle
		unset rc
		parse_file "${enabled_path}/${where}/${named}" "contents"
		while read -d "," line; do
			rm -r "${enabled_path}/${where}/${line}"
			search_in_file "${enabled_path}/${where}/All" "contents" "${line}"
			if (( ! "$rc" )); then
				unset rc
				sed -i "s:${line}::" "${enabled_path}/${where}/All/contents"
				# remove empty line
				sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
			fi
		done <<< "${list_serv[@]}"
		list_serv=()
		unset rc
		rm -r "${enabled_path}/${where}/${named}" 
		
		# remove bundle name on file contents
		search_in_file "${enabled_path}/${where}/All" "contents" "${named}"
		if (( ! "$rc" )); then
			unset rc
			sed -i "s:${named}::" "${enabled_path}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
		fi
		unset rc
	else
		unset rc
		rm -r "${enabled_path}/${where}/${named}"
		# remove service name on file contents
		search_in_file "${enabled_path}/${where}/All" "contents" "${named}"
		if (( ! "$rc" )); then
			unset rc
			sed -i "s:${named}::" "${enabled_path}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
		fi
		unset rc
	fi
	
	unset named
	
	exit 0
}

# ${1} name of the future compiled database
# ${2} name of the source to compile the database
compile(){
	local named rc_curr curr curr_parse
	#named="${1:-current}"
	named="${1}"
	with_="${2}"
	rc_curr=1
	curr=$(which_db current)
	curr_parse=${curr##*/}
	
	check_dir "${database_path}/${named}.old"
	if (( ! "$rc" )); then
		rc_curr=0
		unset rc
	fi
	
	unset rc
	
	if [[ "${named}" == "current" ]] || [[ "${named}" == "${curr_parse}" ]]; then
		named=${curr}
		named=${named##*/}
		if (( "$rc_curr" )); then # .old do not exist
		    cp -rf "${database_path}/${named}" "${database_path}/${named}.old" || die "Impossible to cp ${named} to ${named}.old"
		    s6-rc-update -l "${live_path}" -v"${verbose}" "${database_path}/${named}.old" || die "Impossible to update the new database"
		    rm -r "${database_path}/${named}" || die "Impossible to remove ${named}"
		    make_symlinks "-sfT" "${database_path}/${named}.old" "${database_path}" "current" || die "Impossible to create current symlinks"
		else # .old exist
		    s6-rc-update -l "${live_path}" -v"${verbose}" "${database_path}/${named}.old" || die "Impossible to update the new database"
		    rm -r "${database_path}/${named}" || die "Impossible to remove ${named}"
		    make_symlinks "-sfT" "${database_path}/${named}.old" "${database_path}" "current" || die "Impossible to create current symlinks"
		fi
	fi

	# check exist or not
	check_dir "${database_path}/${named}"
	if (( ! "$rc" )); then
		rm -r "${database_path}/${named}" || die "Impossible to remove ${named}"
	fi
	
	unset rc
	
	# compile new database
	s6-rc-compile -v"${verbose}" "${database_path}/${named}" "${enabled_path}/${with_}" || die "Impossible to compile the new database"
	
	unset named rc_curr curr curr_parse
}

# ${1} name of the database to switch
switch(){
	local named rc_curr rc_first curr curr_parse prev prev_parse
	local -a which_up prev_db
	#named="${1:-current}"
	named="${1}"
	rc_curr=1
	rc_first=1
	curr=$(which_db current)
	curr_parse=${curr##*/}
	prev=$(which_db previous)
	prev_parse=${prev##*/}
	
	# need to know if it's the first use of s6opts
	if [[ "${curr_parse}" == "default" ]] && [[ "${prev_parse}" == "default" ]]; then
		rc_first=0
	fi
	
	# check if exist or not
	check_dir "${database_path}/${named}"
	if (( "$rc" )); then
		unset rc
		die "$named doesn't exist, please choose another one"
	fi
	
	unset rc
	
	# change place of previous symlinks
	make_symlinks "-sfT" "${curr}" "${database_path}" "previous" || die "Impossible to create previous symlinks"
	
	# udpate current database to new database
	s6-rc-update -l "${live_path}" -v"${verbose}" "${database_path}/${named}" || die "Impossible to update the new database"
	
	# search in old db for know what services is new 
	# then bring up only the new services
	
	if (( ! rc_first)); then # first pass?
	    s6-rc -l "${live_path}" -v"${verbose}" -u change all-User
	else
	    curr_parse="${named}"
	    prev=$(which_db previous)
	    prev_parse="${prev##*/}"

	    compare_db "${curr_parse}" "${prev_parse}"
	fi
	
	# update the symlinks to boot with the new database
	make_symlinks "-sfT" "${database_path}/${named}" "${database_path}" "current" || die "Impossible to create current symlinks"
	
	unset named rc_curr rc_first curr curr_parse prev prev_parse 
}

# ${1} name of the future compiled database
# ${2} name of the source to compile the database
compile_switch(){
	local named
	#named="${1:-current}"
	named="${1}"
	who_="${2}"
	
	compile  "${named}" "${who_}" 
	switch "${named}"
	
	unset named
	
	exit 0
}

# ${1} name of symlinks, blank for both
which_db(){
	local named
	named="${1}"
	
	if [[ -z "${named}" ]]; then
		stat -c%N "${database_path}/current"
		stat -c%N "${database_path}/previous"
	else	
		readlink -v "${database_path}/${named}"
	fi
	
	unset named
}

# ${1} which database, blank for live
list_db(){
	local named
	named="${1}"
	
	if [[ -z "${named}" ]]; then
	    s6-rc-db -l "${live_path}" list all
	else
	    s6-rc-db -c "${database_path}/${named}" list all
	fi
	
	unset named
	
	exit 0
}

# ${1} working database directory
list(){
	local named
	named="${1}"
	
	ls -1 --color --group-directories-first "${enabled_path}/${named}"
		
	unset named
}

verbose(){
	local verb
	verb="${1}"
	
	if [[ "${verb}" != @(0|1|2|3) ]]; then
		die "the number must be 0,1,2 or 3"
	fi
	
	sed -i "s:verbose=.*$:verbose=${verb}:" /etc/s6opts/s6opts.conf
	
	unset verb 
	
	exit 0
}

remove_db(){
	local named curr
	named="${1}"
	curr=$(which_db current)
	
	if [[ "${database_path}/${named}" == "${curr}" ]]; then
		die "Removing the current database is not allowed"
	fi
	
	rm -r "${database_path}/${named}"
	
	unset named curr
	
	exit 0
}

# ${1} name of the service
enable(){
	local named
	named="${1}"
	
	check_dir "${classic_available}/${named}"
	if (( ! "$rc" )); then
		unset rc
		if [[ -d "${classic_path}/${named}" ]]; then
			echo_info "${named} already exist at ${classic_path}, do you want to synchronize it [y|n]"
			reply_answer
			if (( ! "$rc" )); then
				unset rc
				cp -ra "${classic_available}/${named}" "${classic_path}/" || die "Impossible to copy ${named} to ${classic_path}"
			else
				unset rc
				echo_valid " Keeping the old version"
			fi
		else
			cp -r "${classic_available}/${named}" "${classic_path}/${named}" || die "Impossible to copy ${named} to ${classic_path}"
		fi
	else
		die "${named} does not exist, choose another one"
	fi
	
	unset rc
	
	if [[ -h "${classic_enabled}/${named}" ]]; then
		echo_info " Already enabled, do you want to send a ALARM signal to ${named} [y|n]"
		reply_answer
		if (( ! "$rc" )); then
			unset rc
			s6-svc -a "${classic_enabled}/""${named}"
		fi
	else
		echo_display " Enable ${named}"
		make_symlinks "-s" "${classic_path}/${named}" "${classic_enabled}" "${named}"
		
		echo_display " Bringing up ${named}"
		s6-svscanctl -an "${classic_enabled}"
	fi
	
	exit 0
}

# ${1} name of the service
disable(){
	local named
	named="${1}"
	link_=$(readlink "${classic_enabled}/${named}")
	
	if [[ "${link_}" != "${classic_path}/${named}" ]]; then
		die " Not a classic service, choose another one"
	fi
	if [[ ! -h "${classic_enabled}/${named}" ]]; then
		echo_info " Not enabled, nothing to do"
		exit 0
	fi

	echo_display " Bringing down ${named}"
	s6-svc -d "${classic_enabled}/""${named}"
	
	check_dir "${classic_path}/${named}"
	if (( ! "$rc" )); then
		rm -rf "${classic_path}/${named}" || die " Impossible to remove ${named}"
	fi
	
	
	
	echo_display " Disable ${named}"
	rm "${classic_enabled}/${named}"
	
	echo_display " Synchronize ${classic_enabled} directory"
	s6-svscanctl -an "${classic_enabled}"
	
	exit 0
	
}
##		sub functions

# ${1} path to the database
# ${2} name of the database
# ${3} searched on to the database
# return rc=0 on success, rc=1 on fail
search_in_db(){
	local path_file named search line_ in_db
	path_file="${1:-${database_path}}"
	named="${2:-current}"
	search="${3}"
	in_db="${path_file}/${named}"
	
	while read line_; do
		case $line_ in
			$search) rc=0 && break ;;
			*) rc=1 ;;
		esac
	done < <(s6-rc-db -c "${in_db}" list all)
	
	unset path_file named search line_ in_db
}

# ${1} path to the file
# ${2} file to parse
parse_file(){
	local check path_file named
	path_file="${1}"
	named="${2}"
	
	while read check; do
		list_serv+=($check,)
	done < "${path_file}/${named}"

	unset check path_file named
}

# ${1} action, must be u for up or d for down
# ${2} name of the bundle/service to bring up/down
bringing(){
	local action named
	action="${1}"
	named="${2}"
	
	echo_display " Bringing ${action} ${named}"
	s6-rc -l "${live_path}" -v${verbose} -"${action}" change "${named}"
	
	unset action named
}

# ${1} current database
# ${2} previous database
compare_db(){
	local curr prev check line_
	local -a curr_db which_up
	curr="${1}"
	prev="${2}"

	mapfile -t curr_db < <(s6-rc-db -c "${database_path}/${curr}" list all)

	while read -d " " check; do
		search_in_db "" "${prev}" "${check}"
		if (( "$rc" )); then
			unset rc
			which_up+=($check,)
		fi
		unset rc
	done <<< "${curr_db[@]}"
	
	# bring up the new service
	while read -d "," line_; do
		bringing "u" "$line_"
	done <<<  "${which_up[@]}"
	
	unset curr prev check line_ curr_db which_up
}

