#!/bin/bash
# Copyright (C) 2015-2016 Eric Vidal <eric@obarun.org>
#
# This file is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.
#
# This scripts is under License Beerware.
#
# "THE BEERWARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal http://obarun.org

#set -e

. /etc/s6opts/s6opts.conf

##		Shell color 

bold=$(tput bold)
reset=$(tput sgr0)
red=$(tput setaf 1)
bred=${bold}$(tput setaf 1)
green=$(tput setaf 2)
bgreen=${bold}$(tput setaf 2)
yellow=$(tput setaf 3)
byellow=${bold}$(tput setaf 3)
blue=$(tput setaf 4)
bblue=${bold}$(tput setaf 4)


## 		Information display by the script 

echo_bold(){
	local msg=$1; shift 
	printf "${bold}${msg}${reset}\n" "${@}" >&1
}
echo_info(){
	local msg=$1; shift 
	printf "${byellow}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_info_menu(){
	local msg=$1; shift 
	printf "${byellow}${msg} ${reset}\n" "${@}" >&1
}
echo_retry(){
	local msg=$1; shift 
	printf "${bblue}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_valid(){
	local msg=$1; shift 
	printf "${bgreen}    ->${msg} ${reset}\n" "${@}" >&1
}
echo_notvalid(){
	local msg=$1; shift 
	printf "${byellow}    ->${msg} ${reset}\n" "${@}" >&1
}
echo_display(){
	local msg=$1; shift 
	printf "${bold}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_error(){
	local msg=$1; shift 
	printf "${bred}    ->${msg} ${reset}\n" "${@}" >&2
}
answer(){
	echo_retry " Please answer y or n :"
}

##		define some variables

reply=""
list_serv=()
rc=""

## 		common functions

die (){
      local message 
      message="$1"
 
      if [[ -n "$message" ]] ; then
        echo "${bred}==>> Error: ${message}${reset}"
      else
        echo "${bred}==>> Error: Script can not continue"
      fi
      exit 1
}

check_elements(){
	for e in "${@:2}"; do [[ "${e}" == "${1}" ]] && break; done;
}

usage(){
	cat << EOF
	
${bold}Usage: ${0} [options] [service_name|database_name]${reset}

General options:
	add : add a service on service database
	remove : remove a service on service database
	compile : compile the service database
	switch : switch the current service database and bring up all new service
	all : compile and switch the current database
	list : list of services on current database
	verbose : be more or less verbose (permanent change)
	remove_db : remove a service database
	which_db : current/previous service database used
EOF
	exit 0
}
##		main fonction

add(){
	local named where
	where="${1}"
	named="${2}"
	
	#check if exist or not
	check_dir "${available_path}/${named}"
	if (( "$rc" )); then # rc=1
		echo_error " ${named} doesn't exist, choose an another name"
		unset rc
		exit 1
	fi	
	unset rc
	
	# check if directory where exist
	# if not, create it with the necessary file/folder
	check_dir "${enabled_path}/${where}"
	if (( "$rc" )); then
		unset rc
		echo_display " ${where} does not exist, create it with the necessary files"
		mkdir -p -m 0755 "${enabled_path}/${where}" || die "Impossible to create the directroy ${enabled_path}/${where}"
		cp -r "${enabled_path}/default/All" "${enabled_path}/${where}" || die "Impossible to copy from ${available_path}/all-User to ${enabled_path}/${where}"
	else
	unset rc
		if ! [[ -d "${enabled_path}/${where}/All" ]]; then
			echo_info " Folder All does not exist, create it" 
			cp -r "${enabled_path}/default/All" "${enabled_path}/${where}" || die "Impossible to copy from ${available_path}/all-User to ${enabled_path}/${where}"
		fi
	fi
	
	unset rc
	
	# bundle or classic service?
	search_in_dir "${available_path}" "${named}" "contents"
	
	# if bundle, create symlink for all name in contents file 
	if (( ! "$rc" )); then # it is a bundle
		unset rc
		parse_file "${available_path}/${named}" "contents"
		while read -d "," line; do
			make_symlinks "-sfT" "${available_path}/${line}" "${enabled_path}/${where}" "${line}"
		done <<< "${list_serv[@]}"
		list_serv=()
		unset rc
		make_symlinks "-sfT" "${available_path}/${named}" "${enabled_path}/${where}" "${named}"
		
		# be sure that the name doesn't exist on file contents
		search_in_file "${enabled_path}/${where}/All" "contents" "${named}"
		if (( "$rc" )); then
			unset rc
			echo "${named}" >> "${enabled_path}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
		fi
		unset rc
	else
		unset rc
		make_symlinks "-sfT" "${available_path}/${named}" "${enabled_path}/${where}" "${named}"
		
		# be sure that the name doesn't exist on file contents
		search_in_file "${enabled_path}/${where}/All" "contents" "${named}"
		if (( "$rc" )); then
			unset rc
			echo "${named}" >> "${enabled_path}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
		fi
		unset rc
	fi
	
	unset named where
	
	exit 0
}

remove(){
	local named
	where="${1}"
	named="${2}"
	
	#check if exist or not
	check_dir "${enabled_path}/${where}" "${named}"
	if (( "$rc" )); then # rc=1
		unset rc
		echo_error " ${named} doesn't exist, choose an another name"
		exit 1
	fi
	unset rc
	
	# bundle or classic service?
	search_in_dir "${available_path}" "${named}" "contents"
	
	# if bundle, remove symlink for all name in contents file 
	if (( ! "$rc" )); then # it is a bundle
		unset rc
		parse_file "${enabled_path}/${where}/${named}" "contents"
		while read -d "," line; do
			rm "${enabled_path}/${where}/${line}"
			search_in_file "${enabled_path}/${where}/All" "contents" "${line}"
			if (( ! "$rc" )); then
				unset rc
				sed -i "s:${line}::" "${enabled_path}/${where}/All/contents"
				# remove empty line
				sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
			fi
		done <<< "${list_serv[@]}"
		list_serv=()
		unset rc
		rm "${enabled_path}/${where}/${named}" 
		
		# remove bundle name on file contents
		search_in_file "${enabled_path}/${where}/All" "contents" "${named}"
		if (( ! "$rc" )); then
			unset rc
			sed -i "s:${named}::" "${enabled_path}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
		fi
		unset rc
	else
		unset rc
		rm "${enabled_path}/${where}/${named}"
		# remove service name on file contents
		search_in_file "${enabled_path}/${where}/All" "contents" "${named}"
		if (( ! "$rc" )); then
			unset rc
			sed -i "s:${named}::" "${enabled_path}/${where}/All/contents"
			# remove empty line
			sed -i "/^\s*$/d" "${enabled_path}/${where}/All/contents"
		fi
		unset rc
	fi
	
	unset named
	
	exit 0
}

compile(){
	local named rc_curr curr curr_parse
	#named="${1:-current}"
	named="${1}"
	with_="${2}"
	rc_curr=1
	curr=$(which_db current)
	curr_parse=${curr##*/}
	
	check_dir "${database_path}/${named}.old"
	if (( ! "$rc" )); then
		rc_curr=0
		unset rc
	fi
	
	unset rc
	
	if [[ "${named}" == "current" ]] || [[ "${named}" == "${curr_parse}" ]]; then
		named=${curr}
		named=${named##*/}
		if (( "$rc_curr" )); then # .old do not exist
		    cp -rf "${database_path}/${named}" "${database_path}/${named}.old" || die "Impossible to cp ${named} to ${named}.old"
		    s6-rc-update -l "${live_path}" -v"${verbose}" "${database_path}/${named}.old" || die "Impossible to update the new database"
		    rm -r "${database_path}/${named}" || die "Impossible to remove ${named}"
		    make_symlinks "-sfT" "${database_path}/${named}.old" "${database_path}" "current" || die "Impossible to create current symlinks"
		else # .old exist
		    s6-rc-update -l "${live_path}" -v"${verbose}" "${database_path}/${named}.old" || die "Impossible to update the new database"
		    rm -r "${database_path}/${named}" || die "Impossible to remove ${named}"
		    make_symlinks "-sfT" "${database_path}/${named}.old" "${database_path}" "current" || die "Impossible to create current symlinks"
		fi
	fi

	# check exist or not
	check_dir "${database_path}/${named}"
	if (( ! "$rc" )); then
		rm -r "${database_path}/${named}" || die "Impossible to remove ${named}"
	fi
	
	unset rc
	
	# compile new database
	s6-rc-compile -v"${verbose}" "${database_path}/${named}" "${enabled_path}/${with_}" || die "Impossible to compile the new database"
	
	unset named rc_curr curr curr_parse
}

switch(){
	local named rc_curr rc_first curr curr_parse prev prev_parse
	local -a which_up prev_db
	#named="${1:-current}"
	named="${1}"
	rc_curr=1
	rc_first=1
	curr=$(which_db current)
	curr_parse=${curr##*/}
	prev=$(which_db previous)
	prev_parse=${prev##*/}
	
	# need to know if it's the first use of s6opts
	if [[ "${curr_parse}" == "default" ]] && [[ "${prev_parse}" == "default" ]]; then
		rc_first=0
	fi
	
	# check if exist or not
	check_dir "${database_path}/${named}"
	if (( "$rc" )); then
		unset rc
		die "$named doesn't exist, please choose another one"
	fi
	
	unset rc
	
	# change place of previous symlinks
	make_symlinks "-sfT" "${curr}" "${database_path}" "previous" || die "Impossible to create previous symlinks"
	
	# udpate current database to new database
	s6-rc-update -l "${live_path}" -v"${verbose}" "${database_path}/${named}" || die "Impossible to update the new database"
	
	# search in old db for know what services is new 
	# then bring up only the new services
	
	if (( ! rc_first)); then # first pass?
	    s6-rc -l "${live_path}" -v"${verbose}" -u change all-User
	else
	    curr_parse="${named}"
	    prev=$(which_db previous)
	    prev_parse="${prev##*/}"

	    compare_db "${curr_parse}" "${prev_parse}"
	fi
	
	# update the symlinks to boot with the new database
	make_symlinks "-sfT" "${database_path}/${named}" "${database_path}" "current" || die "Impossible to create current symlinks"
	
	unset named rc_curr rc_first curr curr_parse prev prev_parse 
}

compile_switch(){
	local named
	#named="${1:-current}"
	named="${1}"
	who_="${2}"
	
	compile  "${named}" "${who_}" 
	switch "${named}"
	
	unset named
	
	exit 0
}

# ${1} name of symlinks
which_db(){
	local named
	named="${1}"
	
	if [[ -z "${named}" ]]; then
		stat -c%N "${database_path}/current"
		stat -c%N "${database_path}/previous"
	else	
		readlink -v "${database_path}/${named}"
	fi
	
	unset named
}

# ${1} which database, blank for live
list_db(){
	local named
	named="${1}"
	
	if [[ -z "${named}" ]]; then
	    s6-rc-db list all
	else
	    s6-rc-db -c "${database_path}/${named}" list all
	fi
	
	unset named
	
	exit 0
}

# ${1} working database directory
list(){
	local named
	named="${1}"
	
	ls -1 --color --group-directories-first "${enabled_path}/${named}"
		
	unset named
}

verbose(){
	local verb
	verb="${1}"
	
	if [[ "${verb}" != @(0|1|2|3) ]]; then
		die "the number must be 0,1,2 or 3"
	fi
	
	sed -i "s:verbose=.*$:verbose=${verb}:" /etc/s6opts/s6opts.conf
	
	unset verb 
	
	exit 0
}

remove_db(){
	local named curr
	named="${1}"
	curr=$(which_db current)
	
	if [[ "${database_path}/${named}" == "${curr}" ]]; then
		die "Removing the current database is not allowed"
	fi
	
	rm -r "${database_path}/${named}"
	
	unset named curr
	
	exit 0
}
enable(){
	local named
	named="${1}"
	
	if [[ -h "${classic_enabled}/${named}" ]]; then
		echo_info " Already enabled, nothing to do"
		exit 0
	fi
	
	check_dir "${classic_available}/${named}"
	if (( ! "$rc" )); then
		unset rc
		if [[ -d "${classic_path}/${named}" ]]; then
			die "${named} already exist at ${classic_path}"
		else
			cp -r "${classic_available}/${named}" "${classic_path}/${named}" || die "Impossible to copy ${named} to ${classic_path}"
		fi
	else
		die "${named} does not exist, choose another one"
	fi
	
	unset rc
	
	echo_display " Enable ${named}"
	make_symlinks "-s" "${classic_path}/${named}" "${classic_enabled}" "${named}"
	
	echo_display " Bringing up ${named}"
	s6-svscanctl -an "${classic_enabled}"
	
	exit 0
}

disable(){
	local named
	named="${1}"
	link_=$(readlink "${classic_enabled}/${named}")
	
	if [[ "${link_}" != "${classic_path}/${named}" ]]; then
		die " Not a classic service, choose another one"
	fi
	if [[ ! -h "${classic_enabled}/${named}" ]]; then
		echo_info " Not enabled, nothing to do"
		exit 0
	fi
	
	check_dir "${classic_path}/${named}"
	if (( ! "$rc" )); then
		rm -r "${classic_path}/${named}" || die " Impossible to remove ${named}"
	fi
	
	echo_display " Disable ${named}"
	rm "${classic_enabled}/${named}"
	
	echo_display " Bringing down ${named}"
	s6-svscanctl -an "${classic_enabled}"
	
	exit 0
	
}
##		sub functions

# ${1} path directories
# ${2} name of directory
# ${3} searched files
# return rc=0 success, rc=1 fail
search_in_dir(){
	local path_dir search named sub_dir here 
	local -a list files
	path_dir="${1}"
	named="${2}"
	search="${3}"
	
	mapfile -t list < <(ls --group-directories-first -m ${path_dir}/)
	
	for sub_dir in "${named}"; do
		mapfile -t files < <(ls --group-directories-first -m ${path_dir}/${named})
		while read -d "," here; do
			case $here in
				$search) rc=0 && break ;;
				*) rc=1 ;;
			esac
		done <<< ${files[@]}
	done <<< "${list[@]}"
	
	unset path_dir search named sub_dir list files here
}


# ${1} path to the file
# ${2} name of the file
# ${3} searched on to the file
# return rc=0 on success, rc=1 on fail
search_in_file(){
	local path_file named search line_ in_file
	path_file="${1}"
	named="${2}"
	search="${3}"
	in_file="${path_file}/${named}"
	
	while read line_;do
		case $line_ in
			$search) rc=0 && break ;;
			*) rc=1 ;;
		esac
	done < "${in_file}"
	
	unset path_file named search line_ in_file
}

# ${1} path to the database
# ${2} name of the database
# ${3} searched on to the database
# return rc=0 on success, rc=1 on fail
search_in_db(){
	local path_file named search line_ in_db
	path_file="${1:-${database_path}}"
	named="${2:-current}"
	search="${3}"
	in_db="${path_file}/${named}"
	
	while read line_; do
		case $line_ in
			$search) rc=0 && break ;;
			*) rc=1 ;;
		esac
	done < <(s6-rc-db -c "${in_db}" list all)
	
	unset path_file named search line_ in_db
}

# ${1} path to the file
# ${2} file to parse
parse_file(){
	local check path_file named
	path_file="${1}"
	named="${2}"
	
	while read check; do
		list_serv+=($check,)
	done < "${path_file}/${named}"

	unset check path_file named
}

# ${1} option to pass
# ${2} target 
# ${3} where to create it
# ${4} name of the symlinks
make_symlinks(){
	local opt target where named
	opt="${1}"
	target="${2}"
	where="${3}"
	named="${4}"

	ln "${opt}" "${target}" "${where}/${named}"

	unset opt target where named
}

# ${1} action, must be u for up or d for down
# ${2} name of the bundle/service to bring up/down
bringing(){
	local action named
	action="${1}"
	named="${2}"
	
	echo_display " Bringing ${action} ${named}"
	s6-rc -l "${live_path}" -v${verbose} -"${action}" change "${named}"
	
	unset action named
}

# ${1} name of the directory
# return rc=0 on success
check_dir(){
	local dir
	dir="${1}"
	if [ -d "${dir}" ]; then
		rc=0
	else
		rc=1
	fi
	
	unset dir
}

# ${1} current database
# ${2} previous database
compare_db(){
	local curr prev check line_
	local -a curr_db which_up
	curr="${1}"
	prev="${2}"

	mapfile -t curr_db < <(s6-rc-db -c "${database_path}/${curr}" list all)

	while read -d " " check; do
		search_in_db "" "${prev}" "${check}"
		if (( "$rc" )); then
			unset rc
			which_up+=($check,)
		fi
		unset rc
	done <<< "${curr_db[@]}"
	
	# bring up the new service
	while read -d "," line_; do
		bringing "u" "$line_"
	done <<<  "${which_up[@]}"
	
	unset curr prev check line_ curr_db which_up
}

